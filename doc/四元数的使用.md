# 四元数在旋转变换中的使用

## 一、什么是四元数？
四元数是一种扩展复数的数学结构，用于表示3D空间中的旋转。相比欧拉角（Euler Angles），它能避免“万向节锁”（Gimbal Lock），并且插值更平滑（如SLERP），因此在图形学、游戏引擎、机器人等领域广泛应用。

一个四元数通常写作：

```c++
q = w + xi + yj + zk
```
或以向量形式表示为：

```c++
q = (w, x, y, z)
```
其中：
w 是实部（scalar part）
(x, y, z) 是虚部（vector part），代表一个3D向量

## 二、四元数表示旋转的含义
✅ 四元数表示的是：绕某个轴旋转一个角度

给定：
旋转轴：单位向量 axis = (ax, ay, az), 旋转角度：θ（弧度）

对应的四元数为：

```c++
q = (cos(θ/2),  ax * sin(θ/2),  ay * sin(θ/2),  az * sin(θ/2))
```
即：

```c++
w = cos(θ/2)
x = ax * sin(θ/2)
y = ay * sin(θ/2)
z = az * sin(θ/2)
```
### 🔍 分量意义总结：
| 分量 | 	名称         | 	物理意义                |
|----|-------------|----------------------|
| w  | 	实部（scalar） | 	表示“未旋转”的程度，越大表示旋转越小 |
| x	 | i 分量        | 	与绕 X 轴旋转相关的部分       |
| y	 | j 分量        | 	与绕 Y 轴旋转相关的部分       |
| z	 | k 分量        | 	与绕 Z 轴旋转相关的部分       |

所以 (x, y, z) 构成的向量方向 = 旋转轴方向，长度 = sin(θ/2)

而 w = cos(θ/2)，所以整个四元数的模长应为 1（单位四元数）

✅ 举例说明

假设你绕 Y 轴（向上）旋转 90°（即 π/2 弧度）：
```c++
θ = π/2
θ/2 = π/4
cos(π/4) = √2/2 ≈ 0.707
sin(π/4) = √2/2 ≈ 0.707
旋转轴 axis = (0, 1, 0)
```
则四元数为：

```c++
q = (0.707,  0,  0.707,  0)
↑       ↑   ↑     ↑
w       x   y     z
表示：绕 Y 轴旋转 90°
```

## 三、如何用四元数旋转一个向量？
要将一个3D向量 v 绕某个轴旋转，可以用四元数 q 进行变换：

```c++
v_rotated = q * v_quat * q⁻¹
```
其中：
- v_quat = (0, vx, vy, vz) 是把向量转成纯虚四元数
- q⁻¹ 是 q 的逆（对于单位四元数，就是共轭 q* = (w, -x, -y, -z)）

但在实际编程中（如GLM），你不需要手动实现，只需：
```c++
glm::quat q = ...; // 你的旋转四元数
glm::vec3 v = ...;  // 要旋转的向量
glm::vec3 v_rotated = q * v; // GLM 重载了 operator*，自动处理
```

## 四、如何计算常用旋转的四元数？（GLM 示例）
 1. 绕某一轴旋转 θ 角度
```c++
float angle_rad = glm::radians(45.0f); // 45度转弧度
glm::vec3 axis = glm::normalize(glm::vec3(0, 1, 0)); // 绕Y轴
glm::quat q = glm::angleAxis(angle_rad, axis);
```
2. 从欧拉角（Yaw, Pitch, Roll）构建四元数
```c++
   float yaw   = glm::radians(90.0f);   // 偏航：绕Y轴
   float pitch = glm::radians(-30.0f);  // 俯仰：绕X轴
   float roll  = glm::radians(10.0f);   // 翻滚：绕Z轴
    // 方法1：先roll，再pitch，最后yaw（常用顺序）
   glm::quat q = glm::quat(glm::vec3(pitch, yaw, roll));

   // 方法2：手动组合
   glm::quat q_yaw   = glm::angleAxis(yaw,   glm::vec3(0,1,0));
   glm::quat q_pitch = glm::angleAxis(pitch, glm::vec3(1,0,0));
   glm::quat q_roll  = glm::angleAxis(roll,  glm::vec3(0,0,1));

   glm::quat q = q_yaw * q_pitch * q_roll; // 注意顺序：右乘 = 先执行右边的旋转
```
⚠️ 顺序很重要！q_yaw * q_pitch * q_roll 表示先 roll，再 pitch，最后 yaw。

## 五、四元数的优点 vs 欧拉角

| 特性	               | 四元数        | 	欧拉角             |
|-------------------|------------|------------------|
| 万向节锁（Gimbal Lock） | 	❌ 不会      | 	✅ 会（如pitch=90°） |
| 插值（动画）	           | ✅ SLERP 平滑 | 	❌ 容易抖动          |
| 存储空间	             | 4个float    | 	3个float         |
| 可读性	              | ❌ 难理解	     | ✅ 直观             |
| 组合旋转              | 	✅ 乘法即可    | 	❌ 容易出错          |

## 六、在你的相机代码中是如何使用的？
回顾你的代码：

```c++
void Camera::updateOrientation()
{
glm::quat yaw   = glm::angleAxis(mYaw,   glm::vec3(0.0f, 1.0f, 0.0f));
glm::quat pitch = glm::angleAxis(mPitch, glm::vec3(1.0f, 0.0f, 0.0f));
mOrientation = pitch * yaw;
mOrientation = glm::normalize(mOrientation);
}
```
✅ 解读：
- yaw：绕 Y 轴（上方向）旋转，控制左右看
- pitch：绕 X 轴（右方向）旋转，控制上下看
- pitch * yaw：先 yaw，再 pitch（注意乘法顺序）

结果 mOrientation 是一个单位四元数，表示当前相机的朝向
然后你用它来旋转基向量：
```c++
mForward = mOrientation * glm::vec3(0.0f, 0.0f, -1.0f);
mUp      = mOrientation * glm::vec3(0.0f, 1.0f, 0.0f);
mRight   = mOrientation * glm::vec3(1.0f, 0.0f, 0.0f);
```
这相当于：
把标准坐标轴 (1,0,0), (0,1,0), (0,0,-1) 用四元数旋转，得到当前相机的局部坐标轴
## 七、四元数的一些重要性质
| 性质	    | 说明                              |
|--------|---------------------------------|
| 单位四元数	 | `                               |
| 逆旋转	   | q⁻¹ = (w, -x, -y, -z)（单位四元数的共轭） |
| 旋转组合	  | q_total = q2 * q1 表示先 q1 再 q2   |
| 恒等旋转	  | q = (1, 0, 0, 0) 表示没有旋转         |

## 总结：四元数分量的意义
| 分量     | 	含义                             |
|--------|---------------------------------|
| w	     | cos(θ/2)，反映旋转量的“剩余”部分           |
| x,y,z	 | axis * sin(θ/2)，方向是旋转轴，长度反映旋转幅度 |
| 整体	    | (w,x,y,z) 构成一个单位向量，完整描述“绕某轴转某角” |

## 小贴士：调试四元数
你可以将四元数转换为欧拉角来查看：

```c++
glm::vec3 eulerAngles = glm::eulerAngles(q); // 返回 (pitch, yaw, roll) 弧度
float yaw   = glm::degrees(eulerAngles.y);
float pitch = glm::degrees(eulerAngles.x);
float roll  = glm::degrees(eulerAngles.z);
```

或者转换为旋转矩阵：

```c++
glm::mat4 rotMatrix = glm::mat4_cast(q)
```